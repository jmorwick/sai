
      /*

      private static <T> Set<Set<T>> 
      		getPartition(Set<T> s, List<List<Boolean>> id) {
    	s = Sets.newHashSet(s);
        Set<Set<T>> partition = Sets.newHashSet();
        for(List<Boolean> row : id) {
          Set<T> rowContents = Sets.newHashSet();
          rowContents.add(s.iterator().next());
          s.remove(s.iterator().next());

          int i=0;
          for(T x : Sets.newHashSet(s)) {
            if(row.get(i)) {
              rowContents.add(x);
              s.remove(x);
            }
            i++;
          }

          partition.add(rowContents);
        }
        return partition;
      }

      //checks whether or not an entry in a partition ID has its maximum value
      private static boolean rowIsMaxed(List<Boolean> row) {
        boolean maxed = true;
        for(Boolean b : row) if(!b) maxed = false;
        return maxed;
      }

      private static List<Boolean> incrementRow(List<Boolean> row) {
        row = Lists.newArrayList(row);
        for(int i=0; i<row.size(); i++) {
          if(row.get(i))
            row.set(i, false);
          else {
            row.set(i, true);
            break;
          }
        }
        return row;
      }

*/
      

/*
      public static <T> Iterator<Set<Set<T>>> getAllSecondOrderSubsets(Set<Set<T>> p) {
        int ts = 0;
        for(Set<T> s : p) ts += s.size();
        final int totalSize = ts;
        final Set<Set<T>> original = p;
        return new Iterator<Set<Set<T>>>() {

      	  private List<Boolean> i;
          {
        	  i = Lists.newArrayList();
              for(int j=0; j<totalSize; j++)
            	  i.add(false);
          }
          
          public boolean hasNext() {
            return i != null;
          }

          public Set<Set<T>> next() {
            if(i == null) return null;
            Set<Set<T>> newP = Sets.newHashSet();
            int j=0;
            for(Set<T> orow : original) {
              Set<T> newrow = Sets.newHashSet();
              for(T x : orow) {
                if(i.get(j)) newrow.add(x);
                j++;
              }
              if(newrow.size() > 0) newP.add(newrow);
            }

            i = getNextSubsetID(i);
            return newP;
          }

          public void remove() {
            throw new UnsupportedOperationException("remove not supported");
          }

        };
      }
      */

    /** return the i-ith mapping from f to t.  This function is deterministic
     * and each i represents a unique mapping for every i from 0 up to the number
     * of possible mappings.
     * @param <FROM>
     * @param <TO>
     * @param f set of keys to be mapped
     * @param t set of values to be mapped to
     * @param i id of the unique mapping to be generated
     * @return a mapping from f to t
     *
      public static <FROM, TO> Map<FROM, TO> getMapping(Set<FROM> f, Set<TO> t, int i) {
        Map<FROM, TO> m = Maps.newHashMap();
        if(i < 0 || i >= possibleMappings(f.size(), t.size()).intValue()) return m;
        
        if(f.size() > t.size()) return reverseMap(getMapping(t, f, i));
        
        f = Sets.newHashSet();
        t = Sets.newHashSet();
        
        for(FROM from : f) {
          int j = i % t.size();
          i /= t.size();
          for(TO to : t) {
            if(j == 0) m.put(from, to);
            j--;
          }
          t.remove(m.get(from));
        }
        return m;
      }
      
      

      private class MappingCollection<FROM, TO> extends AbstractCollection<Map<FROM, TO>> {
        
        private final int max;
        private final Set<FROM> from;
        private final Set<TO> to;
        
        public MappingCollection(Set<FROM> from, Set<TO> to) {
          this.from = from;
          this.to = to;
          max = possibleMappings(from.size(), to.size()).intValue();
        }
        
            @Override
        public boolean isEmpty() { return max == 0; }
        public int size() { return max; }
        public Iterator<Map<FROM, TO>> iterator() {
          return new Iterator<Map<FROM, TO>>() {
            private int i=0;
            public boolean hasNext() { return i < max; }
            public Map<FROM, TO> next() {
              return getMapping(from, to, i++);
            }
            public void remove() {}
          };
        }
      }

    // utility functions for mapping

      private static BigInteger bigFactorial(int x) {
        return bigFactorial(new BigInteger(""+x));
      }
      private static BigInteger bigFactorial(BigInteger x) {
        BigInteger b = BigInteger.ONE;
        for(;x.compareTo(BigInteger.ONE) > 0; x = x.subtract(BigInteger.ONE)) {
          b = b.multiply(x);
        }
        return b;
      }

      private static BigInteger possibleMappings(int n, int k) {
        return possibleMappings(new BigInteger(""+n), new BigInteger(""+k));
      }
      private static BigInteger possibleMappings(BigInteger n, BigInteger k) {
        if(k.compareTo(n) > 0) return possibleMappings(k, n);
        return bigFactorial(n).divide(bigFactorial(n.subtract(k)));
      }
      */
      
      

      
      /** performs a complete, exponential-time search to select as many unique values for each key as possible.*
          public static <K extends Comparable,V extends Comparable> Map<K,V> 
          		findRepresentativesComplete(Multimap<K,V> m) {
              BigInteger max = getNumberOfPartialMappings(m);
              Map<K,V> maxmap = Maps.newHashMap();
              for(BigInteger i = BigInteger.ZERO; i.compareTo(max) < 0; i = i.add(BigInteger.ONE)) {
                  Map<K,V> m2 = getIthPartialMapping(m, i);
                  if(m2.size() > maxmap.size() && isOneToOne(m2))
                      maxmap = m2;
              }
              return maxmap;
          }
          */
          
          

      /** this will be replaced with an iterator-based method *
      @Deprecated public static <K extends Comparable,V extends Comparable> 
      		Map<K,V> getIthPartialMapping(Multimap<K,V> m, BigInteger i) {
          Map<K,V> ret = Maps.newHashMap();
          List<K> keylist = Lists.newArrayList(m.keySet());
          Collections.sort(keylist);
          for(K k : keylist) {
              int j = m.get(k).size()+1;
              if(j < 2 || i.mod(BigInteger.valueOf(j)).intValue() == j-1) continue; // in this case, do not map this node
              List<V> values = Lists.newArrayList(m.get(k));
              Collections.sort(values);
              ret.put(k, values.get(i.mod(BigInteger.valueOf(j)).intValue()));
              i = i.divide(BigInteger.valueOf(j));
          }
          return ret;
      }
      */
      